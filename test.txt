package main

import (
	"encoding/binary"
	"log"
	"net"
	"os/exec"
	"time"
)

func primary(start int, udpBroadcast *net.UDPConn) {

	newBackup := exec.Command("gnome-terminal", "-x", "sh", "-c", "go run backup.go")
	err := newBackup.Run()
	if err != nil {
		log.Fatal(err)
	}

	msg := make([]byte, 1)

	for i := start; ; i++ {
		log.Println(i)
		msg[0] = byte(i)
		udpBroadcast.Write(msg)
		time.Sleep(100 * time.Millisecond)
	}

}

func backup(udpListen *net.UDPConn) int {
	listenChan := make(chan int, 1)
	backupvalue := 0
	go listen(listenChan, udpListen)
	for {
		select {
		case backupvalue = <-listenChan:
			time.Sleep(50 * time.Millisecond)
			break
		case <-time.After(1 * time.Second):
			log.Println("The primary is dead, long live the primary")
			return backupvalue
		}
	}

}

func listen(listenChan chan int, udpListen *net.UDPConn) {

	buffer := make([]byte, 1024)

	for {
		udpListen.ReadFromUDP(buffer[:])
		//if err != nil {log.Fatal(err)}

		listenChan <- int(binary.LittleEndian.Uint64(buffer)) //convert an bytearray to int
		time.Sleep(100 * time.Millisecond)
	}

}

func main() {

	udpAddr, err := net.ResolveUDPAddr("udp", ":20014")
	if err != nil {
		log.Fatal(err)
	}

	udpListen, err := net.ListenUDP("udp", udpAddr)
	if err != nil {
		log.Fatal(err)
	}

	backupvalue := backup(udpListen)

	udpListen.Close()

	udpAddr, err = net.ResolveUDPAddr("udp", "129.241.187.255:20005")
	if err != nil {
		log.Fatal(err)
	}

	udpBroadcast, err := net.DialUDP("udp", nil, udpAddr)
	if err != nil {
		log.Fatal(err)
	}

	primary(backupvalue, udpBroadcast)

	udpBroadcast.Close()

}

//10.100.23.241:45123 fra udp
//10.100.23.11:34933 fra tcp

package main

import (
	"log"
	"net"
	"time"
)

func Receiver(socket *net.TCPConn) {
	var buffer [1024]byte
	for {
		_, err := socket.Read(buffer[:])
		if err != nil {
			log.Fatal(err)
		}
		log.Println(string(buffer[:]))

		_, err = socket.Write([]byte("Hei\x00"))
		if err != nil {
			log.Fatal(err)
		}

		time.Sleep(2 * time.Second)
	}
}

func Listener(socket_connect *net.TCPConn) {
	var buffer [1024]byte
	for {
		_, err := socket_connect.Read(buffer[:])
		if err != nil {
			log.Fatal(err)
		}
		log.Println(string(buffer[:]))

		_, err = socket_connect.Write([]byte("Hade\x00"))
		if err != nil {
			log.Fatal(err)
		}

		time.Sleep(2 * time.Second)
	}
}

func main() {
	reciver_addr, err := net.ResolveTCPAddr("tcp", "10.100.23.11:34933")
	if err != nil {
		log.Fatal(err)
	}

	socket_reciver, err := net.DialTCP("tcp", nil, reciver_addr)
	if err != nil {
		log.Fatal(err)
	}

	//make listener
	listener_addr, err := net.ResolveTCPAddr("tcp", "10.100.23.11:20005")
	if err != nil {
		log.Fatal(err)
	}

	listener, err := net.ListenTCP("tcp", listener_addr)
	if err != nil {
		log.Fatal(err)
	}

	//server connect back
	_, err = socket_reciver.Write([]byte("Connect to: 10.100.23.11:20005\x00"))
	if err != nil {
		log.Fatal(err)
	}

	socket_listener, err := listener.AcceptTCP()
	if err != nil {
		log.Fatal(err)
	}

	go Receiver(socket_reciver)
	go Listener(socket_listener)
}

package main

import (
	"fmt"
	"net"
	"time"
)

func receiver(port int) {
	ServerConn, _ := net.ListenUDP("udp", &net.UDPAddr{IP: []byte{0, 0, 0, 0}, Port: port, Zone: ""})
	defer ServerConn.Close()
	buf := make([]byte, 1024)
	for {
		n, addr, err := ServerConn.ReadFromUDP(buf)
		if err != nil {
			panic("panic")
		}
		fmt.Println("Received ", string(buf[0:n]), " from ", addr)
	}
}

func send(message string, port int) {
	Conn, _ := net.DialUDP("udp", nil, &net.UDPAddr{IP: []byte{10, 100, 23, 241}, Port: port, Zone: ""})
	defer Conn.Close()
	time.Sleep(1 * time.Second)
	Conn.Write([]byte(message))
	fmt.Println("I Sent")
}

func main() {
	go receiver(20005)
	send("Hi Server, How are you doing?", 20005)

	time.Sleep(2 * time.Second)
}

//10.100.23.241:45123
//10.100.23.11:36890

package main

import(
	"net"
	"log"
	"time"
)

//forferdelig funksjonsnavn
func ReadFromWriteTo(socket *net.TCPConn, doneChannel chan bool) {
	var buffer[1024] byte
	var msg = "I am the walrus\x00"
	for {
		//read from server
		_, err := socket.Read(buffer[:])
		if err != nil {log.Fatal(err)}
		log.Println(string(buffer[:]))
		
		//write to server
		_, err = socket.Write([]byte(msg))
		if err != nil {log.Fatal(err)}

		//delay
		time.Sleep(2000*time.Millisecond)
	}
	doneChannel <- true
}

//forferdelig funksjonsnavn
func accept_connection(socket_connect *net.TCPConn, doneChannel chan bool) {
	//new message
	var buffer[1024] byte
	var msg = "I am the not\x00"
	for {
		//read from server
		_, err := socket_connect.Read(buffer[:])
		if err != nil {log.Fatal(err)}
		log.Println(string(buffer[:]))
		
		//write to server
		_, err = socket_connect.Write([]byte(msg))
		if err != nil {log.Fatal(err)}

		//delay
		time.Sleep(2000*time.Millisecond)
	}
	doneChannel <- true
}

func main() {
	//TCP-setup
	raddr, err := net.ResolveTCPAddr("tcp", "129.241.187.136:33546")
	if err != nil {log.Fatal(err)}

	socket, err := net.DialTCP("tcp", nil, raddr)
	if err != nil {log.Fatal(err)}
	
	//declare variables
	var msg = "Connect to: 129.241.187.142:20014\x00"
	
	//make listener
	laddr, err := net.ResolveTCPAddr("tcp", "129.241.187.142:20014")
	if err != nil {log.Fatal(err)}
	
	listener, err := net.ListenTCP("tcp", laddr)
	if err != nil {log.Fatal(err)}
	
	//server connect back
	_, err = socket.Write([]byte(msg))
	if err != nil {log.Fatal(err)}
	
	socket_connect, err := listener.AcceptTCP()
	if err != nil {log.Fatal(err)}
	
	doneChannel := make(chan bool, 1);
	
	go ReadFromWriteTo(socket, doneChannel)
	go accept_connection(socket_connect, doneChannel)
	
	<- doneChannel
}
